## Begin by setting the working drive to location to where the
## folders "Data Analysis", "Functions", and "Simulation Study" are.

## This version of the simulation doesn't require the the RandomFields package.  
## All the data generated by the RandomFields package was generated and saved.
## This simulation reads in that data and uses it to generate the full data.

## While the saved RandomFields data matches the RandomFields data from the original 
## simulations, the full data in this simulation will slightly differ to what was
## used to create the figures in the paper. The reason for this is that in the original 
## Simulations, the seed was set, then the RandomFields data were generated, then the 
## remaining data were generated. Here, the seed is set, the RandomFields data are 
## obtained from a data frame, then the remaining data were generated. As a result, the 
## "remaining data" are generated with different seeds since the RandomFields generation 
## in the original results impacts the seed used to generate the "remaining data".

delim <- "/"

source(paste0("Functions",delim,"WABHProgram.R"))
library(ggplot2)
library(cp4p)
library(dplyr)
library(splines)
library(CAMT)
library(reticulate)

#Reading in different simulation study parameter settings
parlist <- as.matrix(data.frame(read.csv(paste0("Simulation study",delim,"Split Results",delim,"args_list.csv"),header = TRUE, fileEncoding="UTF-8-BOM")))

for(args in 1:54){
  args_list <- as.numeric(unlist(parlist[args,]))

set.seed(66)
B <- 500 # Number of simulations
N <- 200 #number of subjects
x <- seq(1, 100, 1) #Voxel index
M <- length(x)^2 #Number of voxels
K <- as.numeric(args_list[1]) #number of false nulls
#Various data generation parameters#
err_sd <- 0.8
alpha <- 0.05 
beta0 <- -1 #alpha0 star in the paper
eta <- as.numeric(args_list[2])    #theta value in paper draft
C <- as.numeric(args_list[3]) #Controls the heterogeneity 0.5, 1.5, 3
sig_sp <- as.numeric(args_list[4]) #Spatial clustering of signals
lat_sp <- 50 #Spatial clustering of data
start <- as.numeric(args_list[5])

## Reading in the spatial RandomFields data
signal_data_mat <- readRDS(paste0("Simulation study",delim,"RandomFieldsData",delim,"signal_data K=",K," eta=",eta," C=",C," sig_sp=",sig_sp," start=",start,".rds"))
latent_data_mat <- readRDS(paste0("Simulation study",delim,"RandomFieldsData",delim,"latent_data K=",K," eta=",eta," C=",C," sig_sp=",sig_sp," start=",start,".rds"))


### 40/60 Split Setting

Weight_res<- matrix(0,B,3)
Weight_res2<- matrix(0,B,3)
for(k in 1:B){
  set.seed(k + start)
  
  ## Generating the nulls and non-nulls
  signal <- signal_data_mat[k,]
  signal_data <- rep(0,M)
  signal_data[signal] <- 1
  
  ## Generating the latent data (intercepts) alpha0m star in the paper
  data <- latent_data_mat[k,]
  LP_data <- expand.grid(x1=x,x2=x)
  LP_data$Latent_Var <- C*(array(data)-mean(array(data)))/sd(array(data)) #standard deviation is C value
  signal<- seq(1,M,1)[signal_data==1]
  
  ## Generate the X and Y data
  BR_dat <- matrix(0,N,M)
  RE_eff <- err_sd*rnorm(N) # b_i (random effects related to X and Y)
  Y_dat <- 0.5*rnorm(N)+0.5*RE_eff # Y data
  Y_dat <- (Y_dat - mean(Y_dat))/sd(Y_dat)
  eta_samp <- runif(M,0,2*eta) # Alpha coefficients mean is eta
  for(i in 1:M){
    X <- beta0+LP_data$Latent_Var[i]+RE_eff+eta_samp*I(i %in% signal)*Y_dat
    p_X <- exp(X)/(1+exp(X))
    b_X <- rbinom(N,1,p_X)
    BR_dat[,i] <- b_X
  }
  
  trainBR_dat <- BR_dat[1:40,]
  testBR_dat <- BR_dat[41:200,]
  trainY_dat <- Y_dat[1:40]
  testY_dat <- Y_dat[41:200]
  
  ## X bar m
  trainX_mean <- apply(trainBR_dat,2,mean)
  usedtestindicator <- seq(1,M,1)[trainX_mean*(1-trainX_mean)>0]
  
  ##Update BR_dat and true value for each test
  trainBR_dat <- trainBR_dat[,usedtestindicator] 
  signal_data <- signal_data[usedtestindicator]
  
  ## Calculating X_plus
  trainX_pl <- apply(trainBR_dat,1,sum)
  
  ## Update X bar m
  trainX_mean <- apply(trainBR_dat,2,mean)
  
  ##Creat new M value new test number and update signal value
  
  M_new <- length(trainX_mean)
  signal<- seq(1,M_new,1)[signal_data==1]
  
  testBR_dat <- testBR_dat[,usedtestindicator]
  testX_pl <- apply(testBR_dat,1,sum)
  testX_mean <- apply(testBR_dat,2,mean)
  
  ## Running all the logistic regression models for train data
  trainR_sq <- rep(0,M_new)
  trainlm_info <- matrix(0,M_new,4)
  
  ## Running all the logistic regression models for test data
  testR_sq <- rep(0,M_new)
  testlm_info <- matrix(0,M_new,4)
  for(i in 1:M_new){
    traint_X_pl <- (trainX_pl-trainBR_dat[,i])/(M_new-1)
    traint_X_pl <- log(traint_X_pl/(1-traint_X_pl))
    traint_X_pl <- (traint_X_pl - mean(traint_X_pl))/sd(traint_X_pl)
    traint_lm <- lm(trainY_dat~traint_X_pl)
    trainR_sq[i] <- summary(traint_lm)$r.squared
    traint1 <- try(traint_glm <- glm(trainBR_dat[,i] ~trainY_dat+traint_X_pl,family=binomial(link='logit')),silent = TRUE)
    if(attr(traint1,"class")[1] == "try-error"){traint_lm_info <- c(0,1,-999,1)}
    if(attr(traint1,"class")[1] == "glm"){traint_lm_info <- c(summary(traint_glm)$coefficients[2,1:4])}
    trainlm_info[i,] <- traint_lm_info
    
    
    testt_X_pl <- (testX_pl-testBR_dat[,i])/(M_new-1)
    testt_X_pl <- log(testt_X_pl/(1-testt_X_pl))
    testt_X_pl <- (testt_X_pl - mean(testt_X_pl))/sd(testt_X_pl)
    testt_lm <- lm(testY_dat~testt_X_pl)
    testR_sq[i] <- summary(testt_lm)$r.squared
    testt1 <- try(testt_glm <- glm(testBR_dat[,i] ~testY_dat+testt_X_pl,family=binomial(link='logit')),silent = TRUE)
    if(attr(testt1,"class")[1] == "try-error"){testt_lm_info <- c(0,1,-999,1)}
    if(attr(testt1,"class")[1] == "glm"){testt_lm_info <- c(summary(testt_glm)$coefficients[2,1:4])}
    testlm_info[i,] <- testt_lm_info
  }
  
  trainlm_info[,4] <- pnorm(trainlm_info[,3],lower.tail = FALSE) #One-sided test
  trainp_vals <- trainlm_info[,4]
  trainp_vals[trainp_vals==0] <- 1e-20
  p_hat  <- (M_new*pi0est(trainp_vals, lambda = alpha)$pi0 - 1)/M_new
  
  pred_SE <- 1/sqrt(trainX_mean*(1-trainX_mean)*var(trainY_dat)*(40-1)/(1-trainR_sq)) #SEm
  pred_SE <- pred_SE*median(trainlm_info[,2])/median(pred_SE)
  X_dat2 <- data.frame(x1 = LP_data$x1[usedtestindicator],x2 = LP_data$x2[usedtestindicator], pred_SE = pred_SE)
  
  testlm_info[,4] <- pnorm(testlm_info[,3],lower.tail = FALSE) #One-sided test
  testp_vals <- testlm_info[,4]
  testp_vals[testp_vals==0] <- 1e-20
  
  
  ###first set of pm values
  p1 <- rep(1-p_hat,times=M_new)
  wght_pconstant <- weighted_p(trainp_vals,pred_SE, p1, alpha, eta, p_MMW=mean(p1))
  testp_weight_MMW <- testp_vals/(wght_pconstant$MMW_weights)
  testp_weight_MMW[testp_weight_MMW>1] <- 1
  testp_weight_eta <- testp_vals/(wght_pconstant$eta_weights)
  testp_weight_eta[testp_weight_eta>1] <- 1
  
  # WABH CAMT MMW method
  MTR_testconstantpm <- MTR(testp_vals,testp_weight_MMW ,testp_weight_eta,testX_mean,alpha,mean(1-p1),signal,per_val=0.1)
  
  
  #Number of discoveries, true discoveries and false discoveries for all procedures
  Weight_res[k,] <- MTR_testconstantpm$BH_sum$WABH_sum # Each row each iteration
  
  ###second set of pm values with CAMT method
  formulas_mu <- paste0("~ns(pred_SE, df = ", 5, ")")
  formulas_pi <- paste0("~ns(x1, df = ", 5, ")+ns(x2, df = ", 5, ")+ns(x1*x2, df = ", 5, ")")
  
  pi0.var <- model.matrix(as.formula(formulas_pi),data=X_dat2)[,-1]
  f1.var <- model.matrix(as.formula(formulas_mu),data=X_dat2)[,-1]
  
  camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
  
  DF <- 5
  while( !is.null(attr(camt_test, "class")) & DF > 0 ){
    DF <- DF - 1
    if(DF > 0){
      formulas_mu <- paste0("~ns(pred_SE, df = ", DF, ")")
      formulas_pi <- paste0("~ns(x1, df = ", DF, ")+ns(x2, df = ", DF, ")+ns(x1*x2, df = ", DF, ")")
      pi0.var <- model.matrix(as.formula(formulas_pi),data=X_dat2)[,-1]
      f1.var <- model.matrix(as.formula(formulas_mu),data=X_dat2)[,-1]
      camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
    }
    
    if(DF == 0){
      pi0.var <- model.matrix(~ pred_SE, data = X_dat2)[,-1]
      f1.var <- model.matrix(~ x1 + x2, data = X_dat2)[,-1]
      camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
    }
    
  }
  
  if(is.null(attr(camt_test, "class")) ){
    p3 <- 1-camt_test$pi0 #second set of pm values with CAMT method
    
    wght_pcamt2 <- weighted_p(trainp_vals,pred_SE, p3, alpha, eta, p_MMW=0.5)
    wght_pcamt3 <- weighted_p(trainp_vals,pred_SE, p3, alpha, eta, p_MMW=0.9)
    

    testp_weight_camt2MMW <- testp_vals/(wght_pcamt2$MMW_weights)
    testp_weight_camt2MMW[testp_weight_camt2MMW>1] <- 1
    testp_weight_camt3MMW <- testp_vals/(wght_pcamt3$MMW_weights)
    testp_weight_camt3MMW[testp_weight_camt3MMW>1] <- 1
  
    #WABH CAMT MMW p_MMW 0.9 method
    MTR_testcamt <- MTR(testp_vals, testp_weight_camt3MMW, testp_weight_camt2MMW, testX_mean, 
                        alpha, mean(1-p3), signal, per_val=0.1)
    Weight_res2[k,] <- MTR_testcamt$BH_sum$WABH_sum
  }
  
  if(!is.null(attr(camt_test, "class")) ){
    Weight_res2[k,] <- Weight_res[k,]
    cat("CAMT Failed \n")
  }
  
}


res1 <- apply(Weight_res2,2,mean)

FDR_vals1 <- Weight_res2[,3]/Weight_res2[,1]
FDR_vals1[Weight_res2[,1]==0] <- 0

res1 <- c(res1,mean(FDR_vals1))

res_full1 <- Weight_res2


### 100/100 Split Setting

Weight_res<- matrix(0,B,3)
Weight_res2<- matrix(0,B,3)
for(k in 1:B){
  set.seed(k + start)
  
  ## Generating the nulls and non-nulls
  signal <- signal_data_mat[k,]
  signal_data <- rep(0,M)
  signal_data[signal] <- 1
  
  ## Generating the latent data (intercepts) alpha0m star in the paper
  data <- latent_data_mat[k,]
  LP_data <- expand.grid(x1=x,x2=x)
  LP_data$Latent_Var <- C*(array(data)-mean(array(data)))/sd(array(data)) #standard deviation is C value
  signal<- seq(1,M,1)[signal_data==1]
  
  ## Generate the X and Y data
  BR_dat <- matrix(0,N,M)
  RE_eff <- err_sd*rnorm(N) # b_i (random effects related to X and Y)
  Y_dat <- 0.5*rnorm(N)+0.5*RE_eff # Y data
  Y_dat <- (Y_dat - mean(Y_dat))/sd(Y_dat)
  eta_samp <- runif(M,0,2*eta) # Alpha coefficients mean is eta
  for(i in 1:M){
    X <- beta0+LP_data$Latent_Var[i]+RE_eff+eta_samp*I(i %in% signal)*Y_dat
    p_X <- exp(X)/(1+exp(X))
    b_X <- rbinom(N,1,p_X)
    BR_dat[,i] <- b_X
  }
  
  trainBR_dat <- BR_dat[1:100,]
  testBR_dat <- BR_dat[101:200,]
  trainY_dat <- Y_dat[1:100]
  testY_dat <- Y_dat[101:200]
  
  ## X bar m
  trainX_mean <- apply(trainBR_dat,2,mean)
  usedtestindicator <- seq(1,M,1)[trainX_mean*(1-trainX_mean)>0]
  
  ##Update BR_dat and true value for each test
  trainBR_dat <- trainBR_dat[,usedtestindicator] 
  signal_data <- signal_data[usedtestindicator]
  
  ## Calculating X_plus
  trainX_pl <- apply(trainBR_dat,1,sum)
  
  ## Update X bar m
  trainX_mean <- apply(trainBR_dat,2,mean)
  
  ##Creat new M value new test number and update signal value
  
  M_new <- length(trainX_mean)
  signal<- seq(1,M_new,1)[signal_data==1]
  
  testBR_dat <- testBR_dat[,usedtestindicator]
  testX_pl <- apply(testBR_dat,1,sum)
  testX_mean <- apply(testBR_dat,2,mean)
  
  ## Running all the logistic regression models for train data
  trainR_sq <- rep(0,M_new)
  trainlm_info <- matrix(0,M_new,4)
  
  ## Running all the logistic regression models for test data
  testR_sq <- rep(0,M_new)
  testlm_info <- matrix(0,M_new,4)
  for(i in 1:M_new){
    traint_X_pl <- (trainX_pl-trainBR_dat[,i])/(M_new-1)
    traint_X_pl <- log(traint_X_pl/(1-traint_X_pl))
    traint_X_pl <- (traint_X_pl - mean(traint_X_pl))/sd(traint_X_pl)
    traint_lm <- lm(trainY_dat~traint_X_pl)
    trainR_sq[i] <- summary(traint_lm)$r.squared
    traint1 <- try(traint_glm <- glm(trainBR_dat[,i] ~trainY_dat+traint_X_pl,family=binomial(link='logit')),silent = TRUE)
    if(attr(traint1,"class")[1] == "try-error"){traint_lm_info <- c(0,1,-999,1)}
    if(attr(traint1,"class")[1] == "glm"){traint_lm_info <- c(summary(traint_glm)$coefficients[2,1:4])}
    trainlm_info[i,] <- traint_lm_info
    
    
    testt_X_pl <- (testX_pl-testBR_dat[,i])/(M_new-1)
    testt_X_pl <- log(testt_X_pl/(1-testt_X_pl))
    testt_X_pl <- (testt_X_pl - mean(testt_X_pl))/sd(testt_X_pl)
    testt_lm <- lm(testY_dat~testt_X_pl)
    testR_sq[i] <- summary(testt_lm)$r.squared
    testt1 <- try(testt_glm <- glm(testBR_dat[,i] ~testY_dat+testt_X_pl,family=binomial(link='logit')),silent = TRUE)
    if(attr(testt1,"class")[1] == "try-error"){testt_lm_info <- c(0,1,-999,1)}
    if(attr(testt1,"class")[1] == "glm"){testt_lm_info <- c(summary(testt_glm)$coefficients[2,1:4])}
    testlm_info[i,] <- testt_lm_info
  }
  
  trainlm_info[,4] <- pnorm(trainlm_info[,3],lower.tail = FALSE) #One-sided test
  trainp_vals <- trainlm_info[,4]
  trainp_vals[trainp_vals==0] <- 1e-20
  p_hat  <- (M_new*pi0est(trainp_vals, lambda = alpha)$pi0 - 1)/M_new
  
  pred_SE <- 1/sqrt(trainX_mean*(1-trainX_mean)*var(trainY_dat)*(40-1)/(1-trainR_sq)) #SEm
  pred_SE <- pred_SE*median(trainlm_info[,2])/median(pred_SE)
  X_dat2 <- data.frame(x1 = LP_data$x1[usedtestindicator],x2 = LP_data$x2[usedtestindicator], pred_SE = pred_SE)
  
  testlm_info[,4] <- pnorm(testlm_info[,3],lower.tail = FALSE) #One-sided test
  testp_vals <- testlm_info[,4]
  testp_vals[testp_vals==0] <- 1e-20
  
  
  ###first set of pm values
  p1 <- rep(1-p_hat,times=M_new)
  wght_pconstant <- weighted_p(trainp_vals,pred_SE, p1, alpha, eta, p_MMW=mean(p1))
  testp_weight_MMW <- testp_vals/(wght_pconstant$MMW_weights)
  testp_weight_MMW[testp_weight_MMW>1] <- 1
  testp_weight_eta <- testp_vals/(wght_pconstant$eta_weights)
  testp_weight_eta[testp_weight_eta>1] <- 1
  
  # WABH CAMT MMW method
  MTR_testconstantpm <- MTR(testp_vals,testp_weight_MMW ,testp_weight_eta,testX_mean,alpha,mean(1-p1),signal,per_val=0.1)
  
  
  #Number of discoveries, true discoveries and false discoveries for all procedures
  Weight_res[k,] <- MTR_testconstantpm$BH_sum$WABH_sum # Each row each iteration
  
  ###second set of pm values with CAMT method
  formulas_mu <- paste0("~ns(pred_SE, df = ", 5, ")")
  formulas_pi <- paste0("~ns(x1, df = ", 5, ")+ns(x2, df = ", 5, ")+ns(x1*x2, df = ", 5, ")")
  
  pi0.var <- model.matrix(as.formula(formulas_pi),data=X_dat2)[,-1]
  f1.var <- model.matrix(as.formula(formulas_mu),data=X_dat2)[,-1]
  
  camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
  
  DF <- 5
  while( !is.null(attr(camt_test, "class")) & DF > 0 ){
    DF <- DF - 1
    if(DF > 0){
      formulas_mu <- paste0("~ns(pred_SE, df = ", DF, ")")
      formulas_pi <- paste0("~ns(x1, df = ", DF, ")+ns(x2, df = ", DF, ")+ns(x1*x2, df = ", DF, ")")
      pi0.var <- model.matrix(as.formula(formulas_pi),data=X_dat2)[,-1]
      f1.var <- model.matrix(as.formula(formulas_mu),data=X_dat2)[,-1]
      camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
    }
    
    if(DF == 0){
      pi0.var <- model.matrix(~ pred_SE, data = X_dat2)[,-1]
      f1.var <- model.matrix(~ x1 + x2, data = X_dat2)[,-1]
      camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
    }
    
  }
  
  if(is.null(attr(camt_test, "class")) ){
    p3 <- 1-camt_test$pi0 #second set of pm values with CAMT method
    
    wght_pcamt2 <- weighted_p(trainp_vals,pred_SE, p3, alpha, eta, p_MMW=0.5)
    wght_pcamt3 <- weighted_p(trainp_vals,pred_SE, p3, alpha, eta, p_MMW=0.9)
    
    
    testp_weight_camt2MMW <- testp_vals/(wght_pcamt2$MMW_weights)
    testp_weight_camt2MMW[testp_weight_camt2MMW>1] <- 1
    testp_weight_camt3MMW <- testp_vals/(wght_pcamt3$MMW_weights)
    testp_weight_camt3MMW[testp_weight_camt3MMW>1] <- 1
    
    #WABH CAMT MMW p_MMW 0.9 method
    MTR_testcamt <- MTR(testp_vals, testp_weight_camt3MMW, testp_weight_camt2MMW, testX_mean, 
                        alpha, mean(1-p3), signal, per_val=0.1)
    Weight_res2[k,] <- MTR_testcamt$BH_sum$WABH_sum
  }
  
  if(!is.null(attr(camt_test, "class")) ){
    Weight_res2[k,] <- Weight_res[k,]
    cat("CAMT Failed \n")
  }
  
}


res2 <- apply(Weight_res2,2,mean)

FDR_vals2 <- Weight_res2[,3]/Weight_res2[,1]
FDR_vals2[Weight_res2[,1]==0] <- 0

res2 <- c(res2,mean(FDR_vals2))

res_full2 <- Weight_res2

### 200/200 Split Setting

N <- 400 #number of subjects
Weight_res<- matrix(0,B,3)
Weight_res2<- matrix(0,B,3)
for(k in 1:B){
  set.seed(k + start)
  
  ## Generating the nulls and non-nulls
  signal <- signal_data_mat[k,]
  signal_data <- rep(0,M)
  signal_data[signal] <- 1
  
  ## Generating the latent data (intercepts) alpha0m star in the paper
  data <- latent_data_mat[k,]
  LP_data <- expand.grid(x1=x,x2=x)
  LP_data$Latent_Var <- C*(array(data)-mean(array(data)))/sd(array(data)) #standard deviation is C value
  signal<- seq(1,M,1)[signal_data==1]
  
  ## Generate the X and Y data
  BR_dat <- matrix(0,N,M)
  RE_eff <- err_sd*rnorm(N) # b_i (random effects related to X and Y)
  Y_dat <- 0.5*rnorm(N)+0.5*RE_eff # Y data
  Y_dat <- (Y_dat - mean(Y_dat))/sd(Y_dat)
  eta_samp <- runif(M,0,2*eta) # Alpha coefficients mean is eta
  for(i in 1:M){
    X <- beta0+LP_data$Latent_Var[i]+RE_eff+eta_samp*I(i %in% signal)*Y_dat
    p_X <- exp(X)/(1+exp(X))
    b_X <- rbinom(N,1,p_X)
    BR_dat[,i] <- b_X
  }
  
  trainBR_dat <- BR_dat[1:200,]
  testBR_dat <- BR_dat[201:400,]
  trainY_dat <- Y_dat[1:200]
  testY_dat <- Y_dat[201:400]
  
  ## X bar m
  trainX_mean <- apply(trainBR_dat,2,mean)
  usedtestindicator <- seq(1,M,1)[trainX_mean*(1-trainX_mean)>0]
  
  ##Update BR_dat and true value for each test
  trainBR_dat <- trainBR_dat[,usedtestindicator] 
  signal_data <- signal_data[usedtestindicator]
  
  ## Calculating X_plus
  trainX_pl <- apply(trainBR_dat,1,sum)
  
  ## Update X bar m
  trainX_mean <- apply(trainBR_dat,2,mean)
  
  ##Creat new M value new test number and update signal value
  
  M_new <- length(trainX_mean)
  signal<- seq(1,M_new,1)[signal_data==1]
  
  testBR_dat <- testBR_dat[,usedtestindicator]
  testX_pl <- apply(testBR_dat,1,sum)
  testX_mean <- apply(testBR_dat,2,mean)
  
  ## Running all the logistic regression models for train data
  trainR_sq <- rep(0,M_new)
  trainlm_info <- matrix(0,M_new,4)
  
  ## Running all the logistic regression models for test data
  testR_sq <- rep(0,M_new)
  testlm_info <- matrix(0,M_new,4)
  for(i in 1:M_new){
    traint_X_pl <- (trainX_pl-trainBR_dat[,i])/(M_new-1)
    traint_X_pl <- log(traint_X_pl/(1-traint_X_pl))
    traint_X_pl <- (traint_X_pl - mean(traint_X_pl))/sd(traint_X_pl)
    traint_lm <- lm(trainY_dat~traint_X_pl)
    trainR_sq[i] <- summary(traint_lm)$r.squared
    traint1 <- try(traint_glm <- glm(trainBR_dat[,i] ~trainY_dat+traint_X_pl,family=binomial(link='logit')),silent = TRUE)
    if(attr(traint1,"class")[1] == "try-error"){traint_lm_info <- c(0,1,-999,1)}
    if(attr(traint1,"class")[1] == "glm"){traint_lm_info <- c(summary(traint_glm)$coefficients[2,1:4])}
    trainlm_info[i,] <- traint_lm_info
    
    
    testt_X_pl <- (testX_pl-testBR_dat[,i])/(M_new-1)
    testt_X_pl <- log(testt_X_pl/(1-testt_X_pl))
    testt_X_pl <- (testt_X_pl - mean(testt_X_pl))/sd(testt_X_pl)
    testt_lm <- lm(testY_dat~testt_X_pl)
    testR_sq[i] <- summary(testt_lm)$r.squared
    testt1 <- try(testt_glm <- glm(testBR_dat[,i] ~testY_dat+testt_X_pl,family=binomial(link='logit')),silent = TRUE)
    if(attr(testt1,"class")[1] == "try-error"){testt_lm_info <- c(0,1,-999,1)}
    if(attr(testt1,"class")[1] == "glm"){testt_lm_info <- c(summary(testt_glm)$coefficients[2,1:4])}
    testlm_info[i,] <- testt_lm_info
  }
  
  trainlm_info[,4] <- pnorm(trainlm_info[,3],lower.tail = FALSE) #One-sided test
  trainp_vals <- trainlm_info[,4]
  trainp_vals[trainp_vals==0] <- 1e-20
  p_hat  <- (M_new*pi0est(trainp_vals, lambda = alpha)$pi0 - 1)/M_new
  
  pred_SE <- 1/sqrt(trainX_mean*(1-trainX_mean)*var(trainY_dat)*(40-1)/(1-trainR_sq)) #SEm
  pred_SE <- pred_SE*median(trainlm_info[,2])/median(pred_SE)
  X_dat2 <- data.frame(x1 = LP_data$x1[usedtestindicator],x2 = LP_data$x2[usedtestindicator], pred_SE = pred_SE)
  
  testlm_info[,4] <- pnorm(testlm_info[,3],lower.tail = FALSE) #One-sided test
  testp_vals <- testlm_info[,4]
  testp_vals[testp_vals==0] <- 1e-20
  
  
  ###first set of pm values
  p1 <- rep(1-p_hat,times=M_new)
  wght_pconstant <- weighted_p(trainp_vals,pred_SE, p1, alpha, eta, p_MMW=mean(p1))
  testp_weight_MMW <- testp_vals/(wght_pconstant$MMW_weights)
  testp_weight_MMW[testp_weight_MMW>1] <- 1
  testp_weight_eta <- testp_vals/(wght_pconstant$eta_weights)
  testp_weight_eta[testp_weight_eta>1] <- 1
  
  # WABH CAMT MMW method
  MTR_testconstantpm <- MTR(testp_vals,testp_weight_MMW ,testp_weight_eta,testX_mean,alpha,mean(1-p1),signal,per_val=0.1)
  
  
  #Number of discoveries, true discoveries and false discoveries for all procedures
  Weight_res[k,] <- MTR_testconstantpm$BH_sum$WABH_sum # Each row each iteration
  
  ###second set of pm values with CAMT method
  formulas_mu <- paste0("~ns(pred_SE, df = ", 5, ")")
  formulas_pi <- paste0("~ns(x1, df = ", 5, ")+ns(x2, df = ", 5, ")+ns(x1*x2, df = ", 5, ")")
  
  pi0.var <- model.matrix(as.formula(formulas_pi),data=X_dat2)[,-1]
  f1.var <- model.matrix(as.formula(formulas_mu),data=X_dat2)[,-1]
  
  camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
  
  DF <- 5
  while( !is.null(attr(camt_test, "class")) & DF > 0 ){
    DF <- DF - 1
    if(DF > 0){
      formulas_mu <- paste0("~ns(pred_SE, df = ", DF, ")")
      formulas_pi <- paste0("~ns(x1, df = ", DF, ")+ns(x2, df = ", DF, ")+ns(x1*x2, df = ", DF, ")")
      pi0.var <- model.matrix(as.formula(formulas_pi),data=X_dat2)[,-1]
      f1.var <- model.matrix(as.formula(formulas_mu),data=X_dat2)[,-1]
      camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
    }
    
    if(DF == 0){
      pi0.var <- model.matrix(~ pred_SE, data = X_dat2)[,-1]
      f1.var <- model.matrix(~ x1 + x2, data = X_dat2)[,-1]
      camt_test <- try(camt.fdr(pvals = trainp_vals, pi0.var = pi0.var, f1.var = f1.var, alg.type = "OS", control.method = "hybrid"), silent = TRUE)
    }
    
  }
  
  if(is.null(attr(camt_test, "class")) ){
    p3 <- 1-camt_test$pi0 #second set of pm values with CAMT method
    
    wght_pcamt2 <- weighted_p(trainp_vals,pred_SE, p3, alpha, eta, p_MMW=0.5)
    wght_pcamt3 <- weighted_p(trainp_vals,pred_SE, p3, alpha, eta, p_MMW=0.9)
    
    
    testp_weight_camt2MMW <- testp_vals/(wght_pcamt2$MMW_weights)
    testp_weight_camt2MMW[testp_weight_camt2MMW>1] <- 1
    testp_weight_camt3MMW <- testp_vals/(wght_pcamt3$MMW_weights)
    testp_weight_camt3MMW[testp_weight_camt3MMW>1] <- 1
    
    #WABH CAMT MMW p_MMW 0.9 method
    MTR_testcamt <- MTR(testp_vals, testp_weight_camt3MMW, testp_weight_camt2MMW, testX_mean, 
                        alpha, mean(1-p3), signal, per_val=0.1)
    Weight_res2[k,] <- MTR_testcamt$BH_sum$WABH_sum
  }
  
  if(!is.null(attr(camt_test, "class")) ){
    Weight_res2[k,] <- Weight_res[k,]
    cat("CAMT Failed \n")
  }
  
}


res3 <- apply(Weight_res2,2,mean)

FDR_vals3 <- Weight_res2[,3]/Weight_res2[,1]
FDR_vals3[Weight_res2[,1]==0] <- 0

res3 <- c(res3,mean(FDR_vals3))

res_full3 <- Weight_res2

res <- rbind(res1,res2,res3)

rownames(res) <- c("40/160 Split","100/100 Split","200/200 Split")
colnames(res) <- c("Total Rej","Correct Rej","False Rej","FDR")

res_full <- cbind(res_full1,res_full2,res_full3)
c_names <- c("40/160 Split","100/100 Split","200/200 Split")
colnames(res_full) <- paste0(rep(c_names,each = 3), rep(c("Total", "Correct", "False"),length(c_names)))
rownames(res_full) <- NULL

write.csv(res,file=paste0("Simulation study",delim,"Split Results",delim,"Summarized",delim,"SplitRes K=",K," eta=",eta," C=",C," sig_sp=",sig_sp," start=",start,".csv"))
write.csv(res_full,file=paste0("Simulation study",delim,"Split Results",delim,"By_iteration",delim,"SplitRes_full K=",K," eta=",eta," C=",C," sig_sp=",sig_sp," start=",start,".csv"))

}